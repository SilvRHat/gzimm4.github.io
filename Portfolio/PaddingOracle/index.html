<!-- Gavin Zimmerman
Portfolio and About Me 
-->

<!DOCTYPE html>
<html>
<head>
	<title>PORTFOLIO - Padding Oracle</title>
	<link rel="stylesheet" href="../../Resources/stylev2.css">
	<link href='https://fonts.googleapis.com/css?family=Merriweather' rel='stylesheet'>
</head>
<body>
	<div class="top">
		<div class="topnav">
			<div class="buttons">
				<a href="../../">ABOUT ME</a>
				<a class="active" href="../">PORTFOLIO</a>
				<a href="../../Contact">CONTACT</a>
			</div>
		</div>
		<div id="navfade"></div>
	</div>
	
	<h5 style="
	margin-left: 12.5%;
	top:6vw;
	position: relative;">Padding Oracle Automation</h5>
	
	<div class="main_content" style="
	top: 6vw;
	position: relative;">  
		<div>
			<div class="subbar">
				<a id="about_button" class="subactive">About</a>
				<a id="perf_button">Performance</a>
				<a id="code_button">Source Code</a>
				<a href="../" style="float: right;">Back</a>
			</div>
			<div id="subfade"></div>
		</div>
		
		<div id="about" class="viewing">
			<div class="topic" style="margin-top:0;">
				<h4>MAY 2020 - JUN 2020<br> Python | pycurl</h4>
				<h3>Exposition</h3><br>
				<p class="reg_desc">
					The padding oracle attack is an attack vector which exploits a vulnerability in Cipher Block Chaining mode. It is able to decrypt entire messages without the encryption key. I designed this program to complete the Encrypted Pastebin CTF on Hacker101.
					<br><br>
					The CTF is ranked (Hard) and has 4 flags.
				</p>
			</div>
			
			<div class="topic" style="margin-top:0;">
				<h3>CTF Report</h3><br>
				<p class="reg_desc">
					After going through the problem in its entirety, I came to the following conclusions on how the website operated and where it was vulnerable:
					<br><br>
					The website allows a user to make a post with a title and body. This post is then stored in a SQL database with the body encrypted using AES-128 CBC mode with a random key and IV. The key and SQL Row-id are then placed in a JSON string which is encrypted in AES-128 CBC mode with a random IV and constant key only the server knows. <br><br>
					This string is used as a query to the website. The website then decrypts this input and uses the key and id elements to display the users post. Only valid padding encryptions are accepted, but no message authentication is ever made.<br><br>
					A padding oracle attack may be used on the encrypted query. It is also possible to manipulate this data to change the key or post id (as long as its encrypted right). The post id is never sanitized which allows SQL injection attacks to be made.<br><br>
					After examining the SQL database, there is another table with web-tracking data that contains headers of its visits. Retrieving this data will allow an attacker to see queries of posts they do not own.
				</p>
			</div>
			
			<div class="topic" style="margin-top:0;">
				<h3>How it works</h3><br>
				<p class="reg_desc">
					A brief explanation on CBC and the padding oracle attack.
					<br><br>
					CBC mode has a fixed-size key, and will split messages in fixed block sizes. Encryption starts with an initialization vector often generated randomly, it is then xored with the first block of plaintext. This new product is put through the encryption algorithm and the result is xored with the next block.
					<br><br>
					The size of messages encrypted in CBC mode must be a multiple of the block size. Thus these messages need to be padded, and are padded with the last n bytes set to the value n (03 03 03). If a message is decrypted and does not follow this padding format, a padding error is thrown. The attack vector exploits this behaviour to produce two valid padding messages exploiting the previous block. (03 03 03), (03 02 02), and (03 03 01) will all evaluate to valid messages. This effect can be used to infer what the decrypted bytes are, and what the plaintext is.
				</p>
			</div>
			
			<div class="topic" style="margin-top:0;">
				<h3>Man Page</h3>
				<div class="code_block">
					NAME<br>
					<br>
					paddingOracle.py - decrypt ciphertext without key<br>
					<br>
					SYNOPSIS<br>
					<br>
					python3 paddingOracle.py &lt;block size> &lt;target url><br>
					<br>
					DESCRIPTION<br>
					<br>
					Using the given block size and target url, a number of http requests will be sent, modying input until entire cipher text is decrypted. The cipher text must be in CBC mode. Target url must also contain a query parameter 'post', which may be modified within program configurations. This query contains the ciphertext in base64 to decrypt.<br>
					<br>
					&lt;block size> number of bytes in one cipher block (16, 24, or 32)<br>
					<br>
					&lt;target url> url to target decryption on. Server should validate if some ciphertext had a valid padding and error otherwise.<br>
				</div>
			</div>
		</div>
		
		<div id="performance">
			<div class="topic" style="margin-top:0;">
				<h3>Setup</h3><br>
				<p class="reg_desc">
					Since this program was designed with a specific CTF in hand, this is configured to target a website which can validate padding. The code includes a number of configurations such as query parameter name, encoding/ decoding functions, and what errors to look for. All which can be modified to target a different setup. 
				</p>
			</div>
			
			<div class="topic" style="margin-top:0;">
				<h3>Complexity</h3><br>
				<div class="code_block">
					n - Size of cipher text<br><br>
					Runtime complexity: &theta;(n)<br>
					Space complexity: &theta;(n)<br>
				</div>
				<p class="reg_desc">
					The padding oracle attack can be done decrypting 1 byte at a time from the end of ciphertext to the IV block.
				</p>
			</div>
			
			<div class="topic" style="margin-top:0;">
				<h3>Optimizations</h3><br>
				
				<p class="reg_desc">
					While working on this project I found that instead of testing bytes at random for padding validity; it was possible to use the last plaintext byte as a starting point.<br><br>
					It makes sense in most situations, that english plaintext would have many bytes close in value (because ascii). So by xoring the last plain text byte with the desired padding value and the manipulation byte, you can first test bytes close in value to the last plaintext character.
				</p>
			</div>
			
			<div class="topic" style="margin-top:0;">
				<h3>Performance</h3><br>
				
				<div class="code_block" style="font-family: default;">
					10 cipher blocks of size 16:<br>
					&nbsp;&nbsp;Plaintext Alphabet: Ascii characters; mostly in random sequence<br>
					&nbsp;&nbsp;Avg. Time: 404 seconds<br> 
					&nbsp;&nbsp;Avg. Network Requests: 5960<br> 
					&nbsp;&nbsp;Avg. Response Time: 0.068 seconds<br> 
					&nbsp;&nbsp;Avg. Requests per block: 596<br>
					<br> 
					&nbsp;&nbsp;Max Possible Requests: 40800<br> 
				</div>
				<p class="reg_desc">
					These results were taken when tested on Hacker101's CTF. Response time may vary depending on server. <br>
					Likewise due to prediction optimization, the plaintext may affect how many requests are made.<br>
				</p>
			</div>
		</div>
		
		<div id="source_code">
			<div class="topic" style="margin-top:0;">
				<h3>Source Code</h3><br>
				<p class="reg_desc">
					I've open-sourced this project on GitHub. The files may also be downloaded here.<br><br>
					Git Repo: <a href="https://github.com/gzimm4/Cyber-Security-1/blob/master/paddingOracle.py">Padding Oracle Script</a><br>
					Source: <a href="../../Resources/Code/paddingOracle.py" download="paddingOracle.py">paddingOracle.py</a>
					<br><br>
					Cyber Security Repo:
				</p>
				<div class="code_block">
					git clone https://github.com/gzimm4/Cyber-Security-1/
				</div>
			</div>
			
			<div class="topic" style="margin-top:0;">
				<h3>README</h3><br>
				<div class="code_block" style="font-family: default;">
					Gavin Zimmerman<br>
					Padding Oracle Attack Automation Script<br>
					<br>
					Variables<br>
					&nbsp;&nbsp;TARGET_QUERY - The query parameter containing cipher text; program will modify this input to derive ciher text.<br><br>
					&nbsp;&nbsp;PADDING_ERROR_MSG - Error displayed on html response when padding is invalid<br><br>
					<br>
					Functions<br>
					&nbsp;&nbsp;decode(msg: string) - Decodes utf-8 string into cipher text. Default decodes from base64 first replacing url safe characters.<br><br>
					&nbsp;&nbsp;encode(msg: string) - Encodes cipher text into a utf-8 string. Default encodes into base64 url-safe.<br><br>
					&nbsp;&nbsp;makeRequest(c: pycurl object, url: string) - performs request on given url with pycurl object and returns response.<br><br>
				</div>
			</div>
		</div>
		
	</div>
	
	<script type="text/javascript">
		var topic_map = {"about_button":"about","perf_button":"performance", "code_button":"source_code"};
		var current_button = document.getElementsByClassName("subactive")[0];
		var current_topic = document.getElementsByClassName("viewing")[0];
		
		for (let button in topic_map) {
			let topic = document.getElementById(topic_map[button]);
			button = document.getElementById(button);
			
			if (topic!=current_topic) {
				topic.style="visibility:hidden; position: fixed;";
			};
			button.onclick=(function (){
				current_topic.style="visibility:hidden; position: fixed;";
				current_button.classList.remove("subactive");
				
				current_topic=topic;
				current_button=button;
				
				current_topic.style="";
				current_button.classList.add("subactive");
			})
		};
		
	</script>
</body>
</html>




